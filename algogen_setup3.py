# -*- coding: utf-8 -*-
"""ALGOGEN: SETUP3.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/15pRf2_sDXutzPkyRMeCwiveLQ66HjbYW
"""

POP_SIZE = 500
MUTATION_RATE = 0.4
CROSSOVER_RATE_PARENT = 0.8
TOURNAMENT_SIZE = 3
ELITISM_SIZE = 5
MAX_GENERATIONS = 50000

import copy  # Wajib import ini buat Elitism yang aman
import time
import numpy as np
import random
import itertools

easy1_sudoku = np.array([
    [0, 4, 0, 0, 3, 8, 0, 0, 7],
    [0, 7, 9, 0, 1, 0, 0, 0, 8],
    [0, 5, 8, 0, 0, 0, 0, 2, 0],
    [0, 6, 4, 0, 0, 5, 0, 0, 3],
    [0, 0, 7, 3, 0, 4, 8, 0, 0],
    [2, 0, 0, 7, 0, 0, 5, 6, 0],
    [0, 2, 0, 0, 0, 0, 7, 3, 0],
    [7, 0, 0, 0, 5, 0, 6, 4, 0],
    [4, 0, 0, 1, 9, 0, 0, 8, 5]
])

medium1_sudoku = np.array([
    [6, 0, 0, 0, 3, 0, 0, 0, 1],
    [0, 1, 0, 6, 9, 0, 2, 8, 0],
    [5, 0, 9, 0, 0, 0, 0, 0, 0],
    [0, 6, 2, 0, 8, 3, 0, 0, 0],
    [7, 0, 0, 0, 0, 0, 0, 0, 4],
    [0, 0, 0, 2, 7, 0, 3, 1, 0],
    [0, 0, 0, 0, 0, 0, 5, 0, 2],
    [0, 5, 4, 0, 6, 7, 0, 9, 0],
    [9, 0, 0, 0, 5, 0, 0, 0, 8]
])

hard1_sudoku = np.array([
    [9, 5, 6, 3, 0, 1, 8, 0, 0],
    [0, 0, 0, 0, 4, 0, 2, 0, 0],
    [0, 0, 0, 0, 0, 0, 0, 0, 9],
    [0, 6, 0, 4, 0, 0, 5, 0, 0],
    [4, 0, 0, 0, 6, 0, 0, 0, 7],
    [0, 0, 1, 0, 0, 2, 0, 6, 0],
    [8, 0, 0, 0, 0, 0, 0, 0, 0],
    [0, 0, 7, 0, 9, 0, 0, 0, 0],
    [0, 0, 2, 7, 0, 4, 9, 3, 6],
])

# ------------------------------
# Pretty print Sudoku grid
# ------------------------------
def print_sudoku(grid, title=None):
    if title:
        print("\n" + "=" * 40)
        print(title)
        print("=" * 40)
    for i, row in enumerate(grid):
        row_str = ""
        for j, val in enumerate(row):
            char = "." if val == 0 else str(val)
            sep = " "
            if j in [2, 5]:
                sep = " | "
            row_str += char + sep
        print(row_str)
        if i in [2, 5]:
            print("-" * 21)
    print("=" * 40)

# ------------------------------
# Precompute candidate map (dari GIVENS saja)
# ------------------------------
def precompute_candidate_map(base_grid):
    fixed = base_grid != 0
    cand = {}
    for r in range(9):
        row_used = set(base_grid[r, fixed[r, :]])
        for c in range(9):
            if fixed[r, c]:
                continue
            col_used = set(base_grid[fixed[:, c], c])
            br, bc = (r // 3) * 3, (c // 3) * 3
            block = base_grid[br:br+3, bc:bc+3]
            block_fixed = fixed[br:br+3, bc:bc+3]
            block_used = set(block[block_fixed])
            used = row_used | col_used | block_used
            cand[(r, c)] = set(range(1, 10)) - used
    return cand, fixed

# ------------------------------
# Posisi non-given per blok 3x3
# ------------------------------
def compute_block_positions(base_grid, fixed):
    block_pos = {}
    for bx in range(3):
        for by in range(3):
            rows = range(bx*3, (bx+1)*3)
            cols = range(by*3, (by+1)*3)
            positions = []
            for r in rows:
                for c in cols:
                    if not fixed[r, c]:
                        positions.append((r, c))
            block_pos[(bx, by)] = positions
    return block_pos

# ------------------------------
# Individual: hanya angka non-given per blok
# ------------------------------
def create_individual(base_grid, fixed, block_pos):
    ind = {}
    for (bx, by), positions in block_pos.items():
        br, bc = bx*3, by*3
        block = base_grid[br:br+3, bc:bc+3]
        block_fixed_mask = fixed[br:br+3, bc:bc+3]
        used = set(block[block_fixed_mask])
        missing = list(set(range(1, 10)) - used)         # pastikan blok valid (1..9)
        random.shuffle(missing)
        # len(missing) == jumlah sel non-given pada blok
        ind[(bx, by)] = missing[:len(positions)]
    return ind

# ------------------------------
# Decode: isi non-given ke grid copy
# ------------------------------
def decode_to_grid(base_grid, individual, block_pos):
    grid = base_grid.copy()
    for (bx, by), positions in block_pos.items():
        vals = individual[(bx, by)]
        for i, (r, c) in enumerate(positions):
            grid[r, c] = vals[i]
    return grid

# ------------------------------
# Fitness: duplikasi baris + kolom
# (blok valid by construction)
# ------------------------------
def fitness_individual(individual, base_grid, block_pos):
    # buat set berisi nilai unik per baris dan kolom
    row_vals = [set() for _ in range(9)]
    col_vals = [set() for _ in range(9)]

    # tambahkan semua angka 'given' dulu
    fixed = base_grid != 0
    for r in range(9):
        for c in range(9):
            if fixed[r, c]:
                val = base_grid[r, c]
                row_vals[r].add(val)
                col_vals[c].add(val)

    # tambahkan semua angka dari individu
    for (bx, by), positions in block_pos.items():
        vals = individual[(bx, by)]
        for i, (r, c) in enumerate(positions):
            v = vals[i]
            row_vals[r].add(v)
            col_vals[c].add(v)

    # hitung penalti duplikasi
    score = 0
    for i in range(9):
        score += (9 - len(row_vals[i]))  # baris
        score += (9 - len(col_vals[i]))  # kolom

    return score


# ------------------------------
# Tournament selection
# ------------------------------
def tournament_selection(population, base_grid, block_pos, k=TOURNAMENT_SIZE):
    selected = random.sample(population, k)
    selected.sort(key=lambda ind: fitness_individual(ind, base_grid, block_pos))
    return selected[0]

# ------------------------------
# Crossover: block-wise
# ------------------------------

def crossover1(p1, p2, base_grid, block_pos):
    child = {}
    for bx in range(3):
        for by in range(3):
            key = (bx, by)
            # ambil blok dari salah satu parent
            child[key] = list(p1[key]) if random.random() < 0.5 else list(p2[key])
    return child

def crossover2(p1, p2, base_grid, block_pos):
    """
    Versi efisien tanpa decode_to_grid.
    Menilai skor baris dan kolom langsung dari genotipe per-blok.
    """
    # precompute: isi baris dan kolom untuk kedua parent
    fixed = base_grid != 0
    row_vals_p1 = [set(base_grid[r, fixed[r, :]]) for r in range(9)]
    col_vals_p1 = [set(base_grid[fixed[:, c], c]) for c in range(9)]
    row_vals_p2 = [set(rv) for rv in row_vals_p1]
    col_vals_p2 = [set(cv) for cv in col_vals_p1]

    for (bx, by), positions in block_pos.items():
        vals1 = p1[(bx, by)]
        vals2 = p2[(bx, by)]
        for i, (r, c) in enumerate(positions):
            row_vals_p1[r].add(vals1[i])
            col_vals_p1[c].add(vals1[i])
            row_vals_p2[r].add(vals2[i])
            col_vals_p2[c].add(vals2[i])

    def row_score(row_vals):  # total unique per 3 baris
        return sum(len(row_vals[r]) for r in rows)

    def col_score(col_vals):
        return sum(len(col_vals[c]) for c in cols)

    # hasil child berdasarkan row dan col
    child_row, child_col = {}, {}

    for bx in range(3):
        for by in range(3):
            rows = range(bx*3, (bx+1)*3)
            cols = range(by*3, (by+1)*3)

            sum_r_p1 = sum(len(row_vals_p1[r]) for r in rows)
            sum_r_p2 = sum(len(row_vals_p2[r]) for r in rows)
            sum_c_p1 = sum(len(col_vals_p1[c]) for c in cols)
            sum_c_p2 = sum(len(col_vals_p2[c]) for c in cols)

            child_row[(bx, by)] = list(p2[(bx, by)]) if sum_r_p2 > sum_r_p1 else list(p1[(bx, by)])
            child_col[(bx, by)] = list(p2[(bx, by)]) if sum_c_p2 > sum_c_p1 else list(p1[(bx, by)])

    fit_r = fitness_individual(child_row, base_grid, block_pos)
    fit_c = fitness_individual(child_col, base_grid, block_pos)
    return child_row if fit_r <= fit_c else child_col

# ------------------------------
# MUTATE
# ------------------------------
def mutate(individual, mutation_rate, candidate_map, block_pos):
    new_ind = {k: list(v) for k, v in individual.items()}

    for (bx, by), positions in block_pos.items():
        if len(positions) < 2:
            continue

        # Cuma mutasi kalau random < rate
        if random.random() >= mutation_rate:
            continue

        pairs = list(itertools.combinations(range(len(positions)), 2))
        random.shuffle(pairs)

        for i, j in pairs:
            (r1, c1) = positions[i]
            (r2, c2) = positions[j]
            v1 = new_ind[(bx, by)][i]
            v2 = new_ind[(bx, by)][j]

            # Cek Candidate Map
            cand1 = candidate_map.get((r1, c1), set())
            cand2 = candidate_map.get((r2, c2), set())

            if (v1 in cand2) or (v2 in cand1):
                new_ind[(bx, by)][i], new_ind[(bx, by)][j] = v2, v1
                break

    return new_ind

# ==========================================
# LOCAL SEARCH
# ==========================================
def try_local_fix(individual, base_grid, block_pos):
    best_ind = individual
    # Hitung fitness awal
    current_best_fit = fitness_individual(individual, base_grid, block_pos)

    # Loop semua blok
    for (bx, by), positions in block_pos.items():
        if len(positions) < 2: continue

        # Coba semua kemungkinan tukeran di blok ini
        pairs = list(itertools.combinations(range(len(positions)), 2))

        # Kita clone dulu biar gak ngerusak yang asli
        temp_ind = {k: list(v) for k, v in individual.items()}

        for i, j in pairs:
            # Lakukan Swap
            temp_ind[(bx, by)][i], temp_ind[(bx, by)][j] = temp_ind[(bx, by)][j], temp_ind[(bx, by)][i]

            # Cek skor barunya
            fit = fitness_individual(temp_ind, base_grid, block_pos)

            if fit < current_best_fit:
                return temp_ind, fit

            # Kalau gak bagus, balikin lagi (Swap back) biar bisa cek pasangan lain
            temp_ind[(bx, by)][i], temp_ind[(bx, by)][j] = temp_ind[(bx, by)][j], temp_ind[(bx, by)][i]

    return best_ind, current_best_fit

# ==========================================
# FUNGSI SOLVER
# ==========================================
def solver_setup3(
    base_grid,
    crossover_func,
    log_interval=100,
    callback=None   # callback(gen, grid, fitness)
):
    candidate_map, fixed = precompute_candidate_map(base_grid)
    block_pos = compute_block_positions(base_grid, fixed)
    population = [create_individual(base_grid, fixed, block_pos) for _ in range(POP_SIZE)]

    # contoh individu awal
    sample_ind = population[0]
    print("\n===== Contoh Individu Awal (GENOTYPE) =====")
    for key, val in sample_ind.items():
        print(f"Blok {key}: {val}")

    sample_grid = decode_to_grid(base_grid, sample_ind, block_pos)
    print_sudoku(sample_grid, "Contoh Individu Awal (PHENOTYPE)")

    print("\nMulai evolusi Hybrid (GA + Local Search)...")
    total_start = time.time()

    # === variabel restart (anti-stuck) ===
    stuck_count = 0
    last_best_fit = float('inf')
    RESTART_LIMIT = 1000  # restart jika fitness terbaik tidak membaik selama 1000 generasi

    for gen in range(MAX_GENERATIONS):
        gen_start = time.time()

        # 1) Evaluasi & sort (fitness kecil = lebih baik)
        population.sort(key=lambda ind: fitness_individual(ind, base_grid, block_pos))
        best = population[0]
        best_fit = fitness_individual(best, base_grid, block_pos)

        # 1a) Local Search ringan ketika konflik sudah kecil
        if 0 < best_fit <= 4:
            refined_ind, refined_fit = try_local_fix(best, base_grid, block_pos)
            if refined_fit < best_fit:
                print(f"Local Search! {best_fit} -> {refined_fit}")
                best = refined_ind
                best_fit = refined_fit
                population[0] = best  # perbarui best di populasi

        # 1b) Deteksi stagnasi & restart
        if best_fit == last_best_fit:
            stuck_count += 1
        else:
            stuck_count = 0
            last_best_fit = best_fit

        if stuck_count > RESTART_LIMIT:
            print(f"\nSTUCK pada fitness {best_fit} selama {RESTART_LIMIT} generasi. RESTART populasi...")
            population = [create_individual(base_grid, fixed, block_pos) for _ in range(POP_SIZE)]
            stuck_count = 0
            last_best_fit = float('inf')
            # lanjut ke iterasi berikutnya (skip generational update kali ini)
            continue

        # 1c) Logging terjadwal + callback
        should_log = (log_interval is not None and log_interval > 0 and gen % log_interval == 0)
        if callback is not None and (should_log or best_fit == 0 or gen == MAX_GENERATIONS - 1):
            grid = decode_to_grid(base_grid, best, block_pos)
            callback(gen, grid, best_fit)

        gen_time = time.time() - gen_start
        if should_log or best_fit == 0 or gen == MAX_GENERATIONS - 1:
            print(f"Gen {gen:4d} | Fitness terbaik = {best_fit:2d} | "
                  f"Waktu per generasi = {gen_time:.4f} detik | Stuck: {stuck_count}")

        # 1d) Cek solusi
        if best_fit == 0:
            total_time = time.time() - total_start
            print(f"\n✅ Solusi ditemukan di generasi {gen} (fitness: {best_fit})")
            print(f"Total waktu eksekusi: {total_time:.4f} detik")
            return decode_to_grid(base_grid, best, block_pos)

        # 2) Bangun populasi baru: elit + anak
        # === ELITISM ===
        new_population = []

        # Elitism
        elites = copy.deepcopy(population[:ELITISM_SIZE])
        new_population.extend(elites)
        # === SELECTION → Mating Pool (implisit, tanpa detail metode) ===
        num_offspring = POP_SIZE - ELITISM_SIZE
        for _ in range(num_offspring):
            p1 = tournament_selection(population, base_grid, block_pos)
            p2 = tournament_selection(population, base_grid, block_pos)

            if random.random() < CROSSOVER_RATE_PARENT:
                child = crossover_func(p1, p2, base_grid, block_pos)
            else:
                child = p1 if fitness_individual(p1, base_grid, block_pos) < fitness_individual(p2, base_grid, block_pos) else p2
                child = {k: list(v) for k, v in child.items()}

            child = mutate(child, MUTATION_RATE, candidate_map, block_pos)
            new_population.append(child)

        population = new_population


    total_time = time.time() - total_start
    print("\n❌ Tidak ditemukan solusi dalam batas generasi.")
    print(f"Total waktu eksekusi: {total_time:.4f} detik")
    # kembalikan grid terbaik yang ada
    return decode_to_grid(base_grid, best, block_pos)
